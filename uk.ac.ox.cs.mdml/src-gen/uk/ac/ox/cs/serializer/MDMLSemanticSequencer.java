/*
 * generated by Xtext 2.12.0
 */
package uk.ac.ox.cs.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.ox.cs.mDML.Basic;
import uk.ac.ox.cs.mDML.Constraint;
import uk.ac.ox.cs.mDML.DataClass;
import uk.ac.ox.cs.mDML.DataElement;
import uk.ac.ox.cs.mDML.DataItem;
import uk.ac.ox.cs.mDML.DataModel;
import uk.ac.ox.cs.mDML.DomainRegistry;
import uk.ac.ox.cs.mDML.EnumeratedType;
import uk.ac.ox.cs.mDML.ExtensionItem;
import uk.ac.ox.cs.mDML.Import;
import uk.ac.ox.cs.mDML.MDMLPackage;
import uk.ac.ox.cs.mDML.Predicate;
import uk.ac.ox.cs.mDML.PrimitiveType;
import uk.ac.ox.cs.mDML.Reference;
import uk.ac.ox.cs.mDML.ReferenceType;
import uk.ac.ox.cs.mDML.Relationship;
import uk.ac.ox.cs.services.MDMLGrammarAccess;

@SuppressWarnings("all")
public class MDMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MDMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MDMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MDMLPackage.BASIC:
				sequence_Basic(context, (Basic) semanticObject); 
				return; 
			case MDMLPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case MDMLPackage.DATA_CLASS:
				sequence_DataClass(context, (DataClass) semanticObject); 
				return; 
			case MDMLPackage.DATA_ELEMENT:
				sequence_DataElement(context, (DataElement) semanticObject); 
				return; 
			case MDMLPackage.DATA_ITEM:
				sequence_DataItem(context, (DataItem) semanticObject); 
				return; 
			case MDMLPackage.DATA_MODEL:
				sequence_DataModel(context, (DataModel) semanticObject); 
				return; 
			case MDMLPackage.DOMAIN_REGISTRY:
				sequence_DomainRegistry(context, (DomainRegistry) semanticObject); 
				return; 
			case MDMLPackage.ENUMERATED_TYPE:
				sequence_EnumeratedType(context, (EnumeratedType) semanticObject); 
				return; 
			case MDMLPackage.EXTENSION_ITEM:
				sequence_ExtensionItem(context, (ExtensionItem) semanticObject); 
				return; 
			case MDMLPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MDMLPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case MDMLPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case MDMLPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case MDMLPackage.REFERENCE_TYPE:
				sequence_ReferenceType(context, (ReferenceType) semanticObject); 
				return; 
			case MDMLPackage.RELATIONSHIP:
				sequence_Relationship(context, (Relationship) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Basic returns Basic
	 *
	 * Constraint:
	 *     (typename='STRING' | typename='INT' | typename='BOOLEAN')
	 */
	protected void sequence_Basic(ISerializationContext context, Basic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (name=QualifiedName src=DataElement? pred=[Predicate|ID] dest=DataElement?)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationSource returns DataClass
	 *     RelationDestination returns DataClass
	 *     ContainerElement returns DataClass
	 *     DataClass returns DataClass
	 *
	 * Constraint:
	 *     (
	 *         status=Status 
	 *         guid=GUID 
	 *         refines=REFINE 
	 *         name=QualifiedName 
	 *         dataelements+=ContainerElement* 
	 *         extension+=ExtensionItem*
	 *     )
	 */
	protected void sequence_DataClass(ISerializationContext context, DataClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationSource returns DataElement
	 *     RelationDestination returns DataElement
	 *     ContainerElement returns DataElement
	 *     DataElement returns DataElement
	 *
	 * Constraint:
	 *     (status=Status guid=GUID refines=REFINE name=QualifiedName type=[DataType|QualifiedName])
	 */
	protected void sequence_DataElement(ISerializationContext context, DataElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.DATA_ELEMENT__STATUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.DATA_ELEMENT__STATUS));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.DATA_ELEMENT__GUID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.DATA_ELEMENT__GUID));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.DATA_ELEMENT__REFINES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.DATA_ELEMENT__REFINES));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.CONTAINER_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.CONTAINER_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.DATA_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.DATA_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataElementAccess().getStatusStatusParserRuleCall_2_0(), semanticObject.getStatus());
		feeder.accept(grammarAccess.getDataElementAccess().getGuidGUIDParserRuleCall_4_0(), semanticObject.getGuid());
		feeder.accept(grammarAccess.getDataElementAccess().getRefinesREFINEParserRuleCall_9_0(), semanticObject.getRefines());
		feeder.accept(grammarAccess.getDataElementAccess().getNameQualifiedNameParserRuleCall_10_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDataElementAccess().getTypeDataTypeQualifiedNameParserRuleCall_12_0_1(), semanticObject.eGet(MDMLPackage.Literals.DATA_ELEMENT__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataItem returns DataItem
	 *
	 * Constraint:
	 *     (
	 *         dataitem=DataModel | 
	 *         dataitem=DataClass | 
	 *         dataitem=DataElement | 
	 *         dataitem=DataType | 
	 *         dataitem=Import | 
	 *         dataitem=ExtensionItem
	 *     )
	 */
	protected void sequence_DataItem(ISerializationContext context, DataItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataModel returns DataModel
	 *     RelationSource returns DataModel
	 *     RelationDestination returns DataModel
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         status=Status 
	 *         guid=GUID 
	 *         refines=REFINE 
	 *         elements+=DataItem* 
	 *         relations+=Relationship* 
	 *         constraint+=Constraint* 
	 *         predicate+=Predicate*
	 *     )
	 */
	protected void sequence_DataModel(ISerializationContext context, DataModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainRegistry returns DomainRegistry
	 *
	 * Constraint:
	 *     registeredItems+=DataModel+
	 */
	protected void sequence_DomainRegistry(ISerializationContext context, DomainRegistry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationSource returns EnumeratedType
	 *     RelationDestination returns EnumeratedType
	 *     DataType returns EnumeratedType
	 *     EnumeratedType returns EnumeratedType
	 *
	 * Constraint:
	 *     (
	 *         status=Status 
	 *         guid=GUID 
	 *         refines=REFINE 
	 *         name=QualifiedName 
	 *         type=PrimitiveType 
	 *         (array?='[' length=INT?)?
	 *     )
	 */
	protected void sequence_EnumeratedType(ISerializationContext context, EnumeratedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtensionItem returns ExtensionItem
	 *
	 * Constraint:
	 *     (key=ID value=STRING)
	 */
	protected void sequence_ExtensionItem(ISerializationContext context, ExtensionItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.EXTENSION_ITEM__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.EXTENSION_ITEM__KEY));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.EXTENSION_ITEM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.EXTENSION_ITEM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtensionItemAccess().getKeyIDTerminalRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getExtensionItemAccess().getValueSTRINGTerminalRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Predicate
	 *
	 * Constraint:
	 *     (name=QualifiedName predicate=STRING)
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.PREDICATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.PREDICATE__NAME));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.PREDICATE__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.PREDICATE__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateAccess().getPredicateSTRINGTerminalRuleCall_3_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelationSource returns PrimitiveType
	 *     RelationDestination returns PrimitiveType
	 *     DataType returns PrimitiveType
	 *     PrimitiveType returns PrimitiveType
	 *
	 * Constraint:
	 *     (
	 *         status=Status 
	 *         guid=GUID 
	 *         refines=REFINE 
	 *         name=QualifiedName 
	 *         type=Basic 
	 *         rule=[Constraint|ID]?
	 *     )
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, PrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationSource returns ReferenceType
	 *     RelationDestination returns ReferenceType
	 *     DataType returns ReferenceType
	 *     ReferenceType returns ReferenceType
	 *
	 * Constraint:
	 *     (status=Status guid=GUID refines=REFINE name=QualifiedName type=[DataClass|ID])
	 */
	protected void sequence_ReferenceType(ISerializationContext context, ReferenceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.DATA_TYPE__STATUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.DATA_TYPE__STATUS));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.DATA_TYPE__GUID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.DATA_TYPE__GUID));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.DATA_TYPE__REFINES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.DATA_TYPE__REFINES));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.DATA_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.DATA_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.REFERENCE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.REFERENCE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceTypeAccess().getStatusStatusParserRuleCall_2_0(), semanticObject.getStatus());
		feeder.accept(grammarAccess.getReferenceTypeAccess().getGuidGUIDParserRuleCall_4_0(), semanticObject.getGuid());
		feeder.accept(grammarAccess.getReferenceTypeAccess().getRefinesREFINEParserRuleCall_9_0(), semanticObject.getRefines());
		feeder.accept(grammarAccess.getReferenceTypeAccess().getNameQualifiedNameParserRuleCall_10_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getReferenceTypeAccess().getTypeDataClassIDTerminalRuleCall_12_0_1(), semanticObject.eGet(MDMLPackage.Literals.REFERENCE_TYPE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Reference returns Reference
	 *     ContainerElement returns Reference
	 *
	 * Constraint:
	 *     (name=ID type=[DataItem|ID])
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.CONTAINER_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.CONTAINER_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.REFERENCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getReferenceAccess().getTypeDataItemIDTerminalRuleCall_3_0_1(), semanticObject.eGet(MDMLPackage.Literals.REFERENCE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Relationship returns Relationship
	 *
	 * Constraint:
	 *     (src=RelationSource dest=RelationDestination)
	 */
	protected void sequence_Relationship(ISerializationContext context, Relationship semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.RELATIONSHIP__SRC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.RELATIONSHIP__SRC));
			if (transientValues.isValueTransient(semanticObject, MDMLPackage.Literals.RELATIONSHIP__DEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MDMLPackage.Literals.RELATIONSHIP__DEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationshipAccess().getSrcRelationSourceParserRuleCall_1_0_0(), semanticObject.getSrc());
		feeder.accept(grammarAccess.getRelationshipAccess().getDestRelationDestinationParserRuleCall_1_2_0(), semanticObject.getDest());
		feeder.finish();
	}
	
	
}
